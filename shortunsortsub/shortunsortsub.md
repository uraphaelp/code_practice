## 找出数组中长度最小的无序的序列，返回该序列长度 (按升序排列)
eg `[2, 6, 4, 8, 10, 9, 15] unorder:[6,4,8,10,9], so return 5`

## 算法分析：
找出从左侧开始的第一个无序元素位置 `left`, 找出从右侧开始的第一个无序元素位置 `right`

`right-left` 中间这段长度的必然需要重排列

但有可能 `left--->right` 这段之中还有小于左侧有序序列的元素，或大于右侧有序序列的元素

如 `[1, 2, 3, 0, 10, 6, 7, 8, 9, 10]`: `left=3, right=6; tmpsub=[3, 0, 10, 6]` 中显然 `0<min[1,2,3], 10>max[6,7,8,9,10]`

所以此时还需细化排列：分别找出 `min and max of subtmp` 在左侧和右侧有序序列的位置 `left` 以及 `right`即可：

`return right-left+1`
